=====================================================================
                   ARM64プロセッサ依存部マニュアル
                                  Last Modified: 2017 Dec 28 12:03:07
=====================================================================

○概要

ARMにはアーキテクチャバージョンが幾つか存在する．本カーネルでは，
ARMv8 AArch64のアーキテクチャをサポートすることとする．


○開発環境

コンパイラは，LinaroでリリースされているGNU C/C++のバイナリを使用する
こととする．


○カーネルの使用リソース

プロセッサ毎にカーネルは以下のリソースを使用する．

●コア内蔵タイマ

カーネルのティックとして用いる．
Generic Timer(ARMv8コアに内蔵のタイマ)のNon-Secure EL1 physical timer

●Thread ID レジスタ（Privileged Only Thread and Process ID Register）

自プロセッサのPCBアクセスを効率化するため，PCBへのポインタを格納する．
使用しない場合は，core_pcb.h の USE_THREAD_ID_PCB の定義を無効にするこ
と．


○CPU例外の取り扱い

●例外とPCの関連

例外発生後の戻り先を指定するために，戻り先のPCを設定する機能を提供する．
ユーザはCPU例外ハンドラでこれらの機能を用いて戻り先のアドレスを設定する．

      uint64_t x_get_exc_raddr(void *p_excinf);

      void x_set_exc_raddr(void *p_excinf, uint32_t pc);

●CPU例外ハンドラ番号

例外毎に次のようにCPU例外ハンドラ番号を割り付ける．
ただし，通常の動作では4-7以外の例外は発生しない.

スタックポインタとしてSP_EL0を選択し，
EL1実行時に例外発生しEL1のままだった場合
Synchronous Exception	0
IRQ						1
FIQ						2
System Error			3

スタックポインタとしてSP_ELxを選択し，
EL1実行時に例外発生しEL1のままだった場合
Synchronous Exception	4
IRQ						5
FIQ						6
System Error			7

AArch64でEL0実行時に例外発生してEL1に移った場合
Synchronous Exception	8
IRQ						9
FIQ						10
System Error			11

AArch32でEL0実行時に例外発生してEL1に移った場合
Synchronous Exception	12
IRQ						13
FIQ						14
System Error			15

●ベクターテーブル

ARM64のベクタ（vector_table）はターゲット依存部で指定する任意の位置に配置し，
ベクタの先頭アドレスをVector Base Address Register EL1(VBAR_EL1)に設定する.

●ベクタの保護

前述の通りARM64のベクタ（vector_table）は，任意の位置に配置される.
ユーザープログラムでベクタを書き換えることが可能となるので注意が必要である．
安全性を高めるためには，ターゲット依存で次の対策を行うことを推奨する．

  ・不揮発性メモリにベクタを置く．
  ・MMUによりベクタの領域を書き込み禁止とする．

●例外フレーム（CPU例外ハンドラへの引数）

FMPカーネルの仕様では，CPU例外ハンドラの引数には，CPU例外に関する情報
を記憶している領域（例外フレーム）の先頭番地が渡される．そのため，CPU
例外発生時のコンテキストを保存したスタックへのポインタを渡す．

例外前の割込み優先度マスクは，PRI(int_t)型の外部表現である．

        例外フレーム(ARMv8 AArch64)    offset (byte)
      ------------------------------
     | 例外発生前のスタックポインタ | 0x000  <-- p_excinf
      ------------------------------
     |            R19               | 0x008
      ------------------------------
     |            R20               | 0x010
      ------------------------------
     |            R21               | 0x018
      ------------------------------
     |            R22               | 0x020
      ------------------------------
     |            R23               | 0x028
      ------------------------------
     |            R24               | 0x020
      ------------------------------
     |            R25               | 0x028
      ------------------------------
     |            R26               | 0x030
      ------------------------------
     |            R27               | 0x038
      ------------------------------
     |            R28               | 0x040
      ------------------------------
     |            R29               | 0x048
      ------------------------------
     |  例外前の割込み優先度マスク  | 0x050
      ------------------------------
     |  例外前のネストカウント      | 0x058
      ------------------------------
     |     例外前のPC(戻り先)       | 0x060
      ------------------------------
     |        例外前のCPSR          | 0x068
      ------------------------------
     |            R0                | 0x070
      ------------------------------
     |            R1                | 0x078
      ------------------------------
     |            R2                | 0x080
      ------------------------------
     |            R3                | 0x088
      ------------------------------
     |            R4                | 0x090
      ------------------------------
     |            R5                | 0x098
      ------------------------------
     |            R6                | 0x0a0
      ------------------------------
     |            R7                | 0x0a8
      ------------------------------
     |            R8                | 0x0b0
      ------------------------------
     |            R9                | 0x0b8
      ------------------------------
     |            R10               | 0x0c0
      ------------------------------
     |            R11               | 0x0c8
      ------------------------------
     |            R12               | 0x0d0
      ------------------------------
     |            R13               | 0x0d8
      ------------------------------
     |            R14               | 0x0e0
      ------------------------------
     |            R15               | 0x0e8
      ------------------------------
     |            R16               | 0x0f0
      ------------------------------
     |            R17               | 0x0f8
      ------------------------------
     |            R18               | 0x100
      ------------------------------
     |            R30               | 0x108
      ------------------------------


○コア依存の初期化ルーチン

コア依存の初期化ルーチンとして，core_initialize()があり，以下の初期
化を行う．

●ベクタテーブルの初期化
ベクタの先頭アドレスをVector Base Address Register EL1(VBAR_EL1)に設定する.

●Thread ID レジスタの初期化

自プロセッサのPCBへのポインタを設定する．

●MMUの初期化

MMUを初期化して，ページテーブルを作成する．

●キャッシュを有効に

IキャッシュとDキャッシュの両方を有効にする．


○コア依存の終了処理ルーチン

コア依存の初期化ルーチンであるcore_exit()では，以下の終了処理を行う．


○SIL関連

ARM64依存部では，SILのスピンロック取得・解放ルーチンを提供する．スピ
ンロックで用いる変数は，コア依存のマスタプロセッサ用初期化ルーチン
（core_mprc_initialize()）で初期化している．


○SafeG対応

SafeG非対応である．


○arm_gccのARM依存部との違い

●例外フレームの構成
例外発生時のデバッグをより容易にするために，例外発生時の
全ての汎用レジスタとスタックポインタを例外フレームに積むコードを追加した．
デフォルトの例外ハンドラは全レジスタの内容を表示する．

●例外発生番地の補正
例外の種類と例外ベクタテーブルの構成が変わった．
AArch64は，従来のAArch32と異なり例外毎に例外発生番地を補正する必要がなくなった.

●例外発生時のジャンプ先テーブル
従来のARM依存部に搭載されていた例外発生時のジャンプ先を
変更するための仕組み(vector_ref_tbl)は廃止した.
これは，AArch64のISAでは例外発生直後に汎用レジスタを書き換えずに
ジャンプ先をvector_ref_tblからロードしてジャンプすることが
できなくなったからである.

●アーキテクチャ指定
現状AArch64で動作するアーキテクチャがARMv8しかないので，
__TARGET_ARCH_ARMによるアーキテクチャの切り替えは削除した.
将来的にARMv9などが登場したら__TARGET_ARCH_ARMにより切り替えることが
望ましい.

●CPUのモード
AARch64では特権や全ての例外モードがEL1に統合された.
アプリもカーネルも常にEL1で動作することになるため，
従来のようなモード切替のコードは必要なくなった.

●FPUサポート
FPU(VFP NEON)のサポートは未実装である．


=====================================================================
                             変更履歴
=====================================================================
2017/12/28
・最初のリリース

以上．
