=====================================================================
                   ARM64プロセッサ依存部マニュアル
                                  Last Modified:2016 Aug 18 01:23:51
=====================================================================

○概要

ARMにはアーキテクチャバージョンが幾つか存在する．本カーネルでは，
ARMv8 AArch64のアーキテクチャをサポートすることとする．


○開発環境

コンパイラは，LinaroでリリースされているGNU C/C++のバイナリを使用する
こととする．


○カーネルの使用リソース

プロセッサ毎にカーネルは以下のリソースを使用する．

●コア内蔵タイマ

カーネルのティックとして用いる．
Generic Timer(ARMv8コアに内蔵のタイマ)のNon-Secure EL1 physical timer

●0番のプロセッサ間割込み

GICの割込み番号0のプロセッサ間割込みをプロセッサ間のディスパッチ要求の
ために用いる．ディスパッチ用のプロセッサ間割込みハンドラのバイパス処理
を用いる場合には，GICの割込み番号1のプロセッサ間割込みも使用する．

●Thread ID レジスタ（Privileged Only Thread and Process ID Register）

自プロセッサのPCBアクセスを効率化するため，PCBへのポインタを格納する．
使用しない場合は，core_pcb.h の USE_THREAD_ID_PCB の定義を無効にするこ
と．


○CPU例外の取り扱い

●例外とPCの関連

例外発生後の戻り先を指定するために，戻り先のPCを設定する機能を提供する．
ユーザはCPU例外ハンドラでこれらの機能を用いて戻り先のアドレスを設定する．

      uint64_t x_get_exc_raddr(void *p_excinf);

      void x_set_exc_raddr(void *p_excinf, uint32_t pc);

●CPU例外ハンドラ番号

例外毎に次のようにCPU例外ハンドラ番号を割り付ける．
ただし，通常の動作では4-7以外の例外は発生しない.

スタックポインタとしてSP_EL0を選択し，
EL1実行時に例外発生しEL1のままだった場合
Synchronous Exception	0
IRQ						1
FIQ						2
System Error			3

スタックポインタとしてSP_ELxを選択し，
EL1実行時に例外発生しEL1のままだった場合
Synchronous Exception	4
IRQ						5
FIQ						6
System Error			7

AArch64でEL0実行時に例外発生してEL1に移った場合
Synchronous Exception	8
IRQ						9
FIQ						10
System Error			11

AArch32でEL0実行時に例外発生してEL1に移った場合
Synchronous Exception	12
IRQ						13
FIQ						14
System Error			15

●ベクターテーブル

ARM64のベクタ（vector_table）はターゲット依存部で指定する任意の位置に配置し，
ベクタの先頭アドレスをVector Base Address Register EL1(VBAR_EL1)に設定する.

●ベクタの保護

前述の通りARM64のベクタ（vector_table）は，任意の位置に配置される.
ユーザープログラムでベクタを書き換えることが可能となるので注意が必要である．
安全性を高めるためには，ターゲット依存で次の対策を行うことを推奨する．

  ・不揮発性メモリにベクタを置く．
  ・MMUによりベクタの領域を書き込み禁止とする．

●例外フレーム（CPU例外ハンドラへの引数）

FMPカーネルの仕様では，CPU例外ハンドラの引数には，CPU例外に関する情報
を記憶している領域（例外フレーム）の先頭番地が渡される．そのため，CPU
例外発生時のコンテキストを保存したスタックへのポインタを渡す．

例外前の割込み優先度マスクは，PRI(int_t)型の外部表現である．

        例外フレーム(ARMv8 AArch64)    offset (byte)
      ------------------------------
     | 例外発生前のスタックポインタ | 0x000  <-- p_excinf
      ------------------------------
     |            R19               | 0x008
      ------------------------------
     |            R20               | 0x010
      ------------------------------
     |            R21               | 0x018
      ------------------------------
     |            R22               | 0x020
      ------------------------------
     |            R23               | 0x028
      ------------------------------
     |            R24               | 0x020
      ------------------------------
     |            R25               | 0x028
      ------------------------------
     |            R26               | 0x030
      ------------------------------
     |            R27               | 0x038
      ------------------------------
     |            R28               | 0x040
      ------------------------------
     |            R29               | 0x048
      ------------------------------
     |  例外前の割込み優先度マスク  | 0x050
      ------------------------------
     |  例外前のネストカウント      | 0x058
      ------------------------------
     |     例外前のPC(戻り先)       | 0x060
      ------------------------------
     |        例外前のCPSR          | 0x068
      ------------------------------
     |            R0                | 0x070
      ------------------------------
     |            R1                | 0x078
      ------------------------------
     |            R2                | 0x080
      ------------------------------
     |            R3                | 0x088
      ------------------------------
     |            R4                | 0x090
      ------------------------------
     |            R5                | 0x098
      ------------------------------
     |            R6                | 0x0a0
      ------------------------------
     |            R7                | 0x0a8
      ------------------------------
     |            R8                | 0x0b0
      ------------------------------
     |            R9                | 0x0b8
      ------------------------------
     |            R10               | 0x0c0
      ------------------------------
     |            R11               | 0x0c8
      ------------------------------
     |            R12               | 0x0d0
      ------------------------------
     |            R13               | 0x0d8
      ------------------------------
     |            R14               | 0x0e0
      ------------------------------
     |            R15               | 0x0e8
      ------------------------------
     |            R16               | 0x0f0
      ------------------------------
     |            R17               | 0x0f8
      ------------------------------
     |            R18               | 0x100
      ------------------------------
     |            R30               | 0x108
      ------------------------------


○割り込みの取り扱い

●カーネル管理内/外の割込み

IRQをカーネル管理内，FIQをカーネル管理外の割込みとする．

●CPUロックフラグ

CPUロックフラグとして，ステータスレジスタのIRQビットを用いる．すなわち
，CPUロック状態では，IRQビットをセットし，カーネル管理内の割込みを禁止
し，CPUロック解除状態では，IRQビットをクリアする．

●割込みロックフラグ

割込みロックフラグとしては，CPSRのFIQビットとIRQビットを用いる．割り込
みロック状態では，IRQビットとFIQビットをセットする．


○割込み処理関係

割込みはGICを用いて扱う．

●割込みハンドラ番号と割込み番号

GICで割付けられている番号を割込みハンドラ番号及び割込み番号とする．コ
アに割り付けられるローカルな割込みに関しては，上位ビットで割り付けられ
ているコアのビットを入れることで，識別する．グローバルな割込みは，上位
ビットが0xfとなっている．

●割込み優先度の最小値と最大値

割込み優先度の最小値は-15であり，最大値は-1である．

●dis_int/ena_int のサポート

dis_int/ena_intをサポートしている．

●カーネル管理外の割込みサポート

カーネル管理外の割込みはサポートしていない．

●ATT_ISRの割付クラスの制限

ハードウェア的に全プロセッサにも割り付け可能な割込み（割込み番号の上位
16ビットが0）に対するATT_ISRは，割り付け可能プロセッサが初期割付けプロ
セッサのみのクラスに割り付け可能である．


○性能評価用システム時刻の参照

コア内蔵タイマによる get_utm をサポートしている．


○コア依存のマスタプロセッサ用初期化ルーチン

カーネル起動時に str_ker() の実行前に呼び出されるルーチンとして，
core_mprc_initialize() があり，以下の初期化を行う．

●GICの初期化

GICを一旦無効にして，全ての割込みを禁止した上で，ペンディングビットを
クリアした後，有効にする．

●SILのスピンロック用変数の初期化

SILのスピンロック関数を有効にするため，スピンロック変数を有効にする．


○コア依存の初期化ルーチン

コア依存の初期化ルーチンとして，core_initialize()があり，以下の初期
化を行う．

●ベクタテーブルの初期化
ベクタの先頭アドレスをVector Base Address Register EL1(VBAR_EL1)に設定する.

●Thread ID レジスタの初期化

自プロセッサのPCBへのポインタを設定する．

●MMUの初期化

MMUを初期化して，ページテーブルを作成する．

●キャッシュを有効に

IキャッシュとDキャッシュの両方を有効にする．

●GICのCPUインタフェースを有効に

プロセッサの割込み優先度を最低優先度とし，割込み優先度の全ビットを有効
にして，EOIによりペンディングしている割込みをクリアする．


○コア依存の終了処理ルーチン

コア依存の初期化ルーチンであるcore_exit()では，以下の終了処理を行う．

●GICのCPUインタフェースを停止する

●GICのDISインタフェースの停止


○SIL関連

ARM64依存部では，SILのスピンロック取得・解放ルーチンを提供する．スピ
ンロックで用いる変数は，コア依存のマスタプロセッサ用初期化ルーチン
（core_mprc_initialize()）で初期化している．


○SafeG対応

それぞれの使用するリソースは次の通りである．

SECURE
 ・タイマ
   ・Generic TimerのSecure EL1 physical timer
   
NONSECURE
 ・タイマ
   ・Generic TimerのNon-Secure EL1 physical timer

SafeG向けの機能として，以下の機能を持つ．

●GICのSafeG向け機能

TOPPERS_SAFEG_SECURE を定義することによりセキュアで動作するカーネル向
けの機能を有効とする．
・gic.c/gic_support.S
  ・1022のSpurious割り込みへの対応コード．

TOPPERS_SAFEG_LOAD を定義することにより，CPU利用率の計測を有効とする．
・gic_support.S
  ・割り込みの入り口で計測用の safeg_load_int() を呼び出す．


○arm_gccのARM依存部との違い

●例外フレームの構成
例外発生時のデバッグをより容易にするために，例外発生時の
全ての汎用レジスタとスタックポインタを例外フレームに積むコードを追加した．
デフォルトの例外ハンドラは全レジスタの内容を表示する．

●例外発生番地の補正
例外の種類と例外ベクタテーブルの構成が変わった．
AArch64は，従来のAArch32と異なり例外毎に例外発生番地を補正する必要がなくなった.

●例外発生時のジャンプ先テーブル
従来のARM依存部に搭載されていた例外発生時のジャンプ先を
変更するための仕組み(vector_ref_tbl)は廃止した.
これは，AArch64のISAでは例外発生直後に汎用レジスタを書き換えずに
ジャンプ先をvector_ref_tblからロードしてジャンプすることが
できなくなったからである.

●アーキテクチャ指定
現状AArch64で動作するアーキテクチャがARMv8しかないので，
__TARGET_ARCH_ARMによるアーキテクチャの切り替えは削除した.
将来的にARMv9などが登場したら__TARGET_ARCH_ARMにより切り替えることが
望ましい.

●CPUのモード
AARch64では特権や全ての例外モードがEL1に統合された.
アプリもカーネルも常にEL1で動作することになるため，
従来のようなモード切替のコードは必要なくなった.

●SCUのドライバ
現状では，SCUの設定はARM Trusted Firmwareで行っている．
SCUドライバは未実装である．

●FPUサポート
FPU(VFP NEON)のサポートは未実装である．

●TTSPによる検証時の注意
カーネル内部で扱われる時間の型のサイズが64bitになる．
この関係で従来のTTSP検証プログラムを実行するとエラーが発生する.
TTSP実行時は，TMAX_RELTIMによるE_PARエラーチェックをテスト対象外
とする必要がある．

従来は，sta_alm，及びista_almの第2引数RELTIM型のalmtimに
TMAX_RELTIMを超える値を指定すると，E_PARエラーが発生する．
TTSPでは，TMAX_RELTIMを超える値を指定した際のE_PARエラーの発生をテストしている．
しかし，64bitではTMAX_RELTIMを超えるRELTIM型の値が存在しなくなる．
具体的には，CPUビット幅毎のRELTIMの型と最大値は次のようになる．
内部表現で表現できる数値より小さい値をRELTIMとして扱うルールとなっている．

         RELTIM    内部表現  TMAX_RELTIM
CPU      uint      long
16bit    16bit     32bit     16bit符号無しMAX
32bit    32bit     32bit     32bit符号付きMAX
64bit    32bit     64bit     32bit符号無しMAX

64bitの場合，RELTIMとしてわたせる値は32ビットで表現可能な全ての値なので，
上限値がなく，テストする必要はない．
TMAX_RELTIMによるE_PARエラーチェックをテスト対象外とする必要がある．


=====================================================================
                ターゲット依存部開発者向けの情報
=====================================================================
○マスタプロセッサの指定

マスタプロセッサのプロセッサIDを次のマクロで指定する．

  TMPRC_INDEX


○MMUの初期化ルーチン

MMUの基本的な初期化の終了後，ターゲット依存で行いたいMMUの初期化処理を
以下の関数に記述する．

  void target_mmu_init(void)

ARM64依存部では，MMUの初期化用の関数として次の関数を提供する

  void mmu_map_add(const mmap_t *pmm);

引数のmmap_tは設定したいメモリ領域のサイズやキャッシュの有効無効等を設定する．

    typedef struct{
        uintptr_t	va;
        uintptr_t	pa;
        uintptr_t	size;
        uint8_t		attr;
        uint8_t		ns;
    } mmap_t;


○コンテキストの判定

カーネルは，割り込み/例外の入り口で，カーネル内のカウント用の変数（
excpt_nest_count）をカウントアップし，出口でカウントダウンする．そのた
め，excpt_nest_count が0の場合はタスクコンテキスト，1以上の場合は非タ
スクコンテキストと判断する．


○例外エントリ処理

各例外のエントリ処理は要因毎にカーネルで個別に持つ．JSPではルーチンを
共有していたが，ルーチンを共有化すると，例外発生後，一時的にレジスタを
退避させるために一時領域を用いる必要があるため，個別に持つように変更し
た．

各例外のエントリ処理では以下の処理を行う．

 ・r0-r18,r30(lr),elr,spsrを保存
 ・r10にCPU例外番号を入れる
 ・target_exc_handlerへジャンプ

target_exc_handler はGICドライバで定義している．
target_exc_handler では，前述の例外フレームのフォーマットに従って例外
フレームを作成して，その先頭番地を引数にして，対応するCPU例外ハンドラ
を呼び出す．

FIQのエントリ処理（fiq_handler）については，ターゲット依存部側で用意す
る場合には，それぞれ，以下のマクロを定義すれば，ARM依存部側のエントリ
処理が無効となる．

     TARGET_FIQ_HANDLER


○アイドル処理

実行するべきタスクがない場合は，ディスパッチャーで割込みを許可して，割
込みを待つ（dispatcher_2）．ARM64依存部のコードでは，次のようになってい
る．

       割込みを許可
       nop
       割り込み禁止

ターゲット依存で，上記の処理の代わりに，省電力モード等に移行する処理を
記述したい場合には，ターゲット依存部で，TOPPERS_CUSTOM_IDLEを定義し，
代わりに実行した処理を toppers_asm_custom_idle というアセンブラマクロ
として記述する．

なお，toppers_asm_custom_idle の記述にあたっては，次のレジスタは
oppers_asm_custom_idleの前後で使用するため，oppers_asm_custom_idle 内
で使用する場合は，前後で保存復帰すること．これらのレジスタは Calee 
saved レジスタであるため， oppers_asm_custom_idle として関数呼び出しを
した場合は，呼び出した関数で自動的に保存復帰されるため，アセンブラレベ
ルでの保存復帰は必要ない．

レジスタ: 内容
w19     : '1'
x20     : reqflgのアドレス
x21     : excpt_nest_countのアドレス
sp      : 非タスクコンテキスト用のスタックの先頭アドレス．

アセンブラマクロはC言語記述中に展開するとエラーとなる．core_support.S で
は，TOPPERS_ASM_MACRO というマクロを定義しているため，ターゲット依存部
で toppers_asm_custom_idle アセンブラマクロを定義する際には，
TOPPERS_ASM_MACRO を条件コンパイルの条件として用いること．


○CPSRに常にセットする値

CPSRの変更時，常にセットするパターンを DAIF_ALWAYS_SET として，ターゲ
ット依存部で定義可能である．


○GICドライバ

ARM依存部では，ARM Generic Interrupt Controller Ver.2用のドライバを用
意している(gic.h/gic.c)．このドライバを使用するためには，以下のパラメ
ータを定義する必要がある．

 GICC_BASE  : CPU Interface のベースアドレス
 GICD_BASE   : Distributor のベースアドレス
 GIC_PRI_LEVEL   : 優先度レベル

また，以下のファイルをコンパイル対象とすること．

 gic.c
 gic_support.S


○Makefileでの定義事項


○ARMCC共有コードの記述方法

ARMCCと共有するコードは，次のルールに従ってコードを記述する必要がある．

1.メモリバリア命令(Asm("":::"memory"))のマクロ化

ターゲット依存部 ポーティングガイドの(1-6-2)(c)には，次のように記述さ
れている．

-----
(c) クリティカルセクションの出入処理の本質的な部分が，マクロやインライ
	ン関数呼出しで実現している場合には，クリティカルセクションに入る処
	理の最後と出る処理の先頭に，Asm("":::"memory")という記述を入れる．
-----

メモリバリア命令(Asm("":::"memory"))は，ARMCCと互換性がないため，この
記述をする箇所は，次のマクロで記述すると，コンパイル時に適切なメモリバ
リア命令に置き換えられる．

  ARM_MEMORY_CHANGED

2.インクルード方法

ターゲット依存部 ポーティングガイドの1.5には，次のように記述されている．

-----
その他のヘッダファイルは，「#include "..."」によりインクルードする．ヘッ
ダファイルが，カレントディレクトリやインクルードするファイルと同じディ
レクトリ以外のディレクトリに置かれている場合には，次のようにパス指定を
行う．
-----

GCC依存部とARMCC依存部でヘッダファイルを共有できない場合には，それぞれ
で同じ名前のファイルを持つ．そして，コンパイルオプションでインクルード
すべきファイルを先に指定している．そのため，ARMCCと共有するファイルで
これらのファイルをインクルードする場合には，「#include "..."」ではなく，
「#include <...>」で記述し，相対パスではなくファイル名のみを記載するこ
と．

3.アセンブラディレクティブ

GCCとARMCCのアセンブラディレクティブは互換性がない．そのため，ARMCCと
共有するファイルは次に示すマクロディレクティブで記述すること．

マクロディレクティブ     GCCディレクティブ
 ASECTION(name)          .section name,"a"
 ATEXT                   .text
 AGLOBAL(name)           .global name
 AALIGN(x)               .align x
 ABALIGN(x)              .balign x
 ALONG                   .dword
 ALABEL(label)           label:
 AOR                       |
 AWEAK(name)             .weak name


○ディスパッチ用のプロセッサ間割込みハンドラのバイパス処理

ディスパッチ用のプロセッサ間割込みが入った場合に，割込みハンドラ処理の
バイパスして，ディスパッチャを呼び出すことが可能である．以下のマクロを
定義して，ret_int_ipi_dispatch を呼び出させばよい．

  USE_IPI_DIS_HANDER_BYPASS


○GICによるCPUロック

SafeGを用いてSecure側で実行する際は通常はcpsrのFビットで割込みの禁止を
実現するが，NMFI が有効となっていると，Fビットはセットできない．そのた
め，GICの優先度マスクをCPUロックとして使用する機能を提供する．この機能
を有効をするためには，以下のマクロを定義すること．

 USE_GIC_CPULOCK : CPUロックとしてGICの優先度マスクを使用．


○TrustZoneのサポート

SafeGを用いてSecure/NonSecure側で実行するコンフィギュレーションをサポ
ートする．この機能を有効にするには，以下のマクロを定義すること．

 TOPPERS_SAFEG_SECURE : TrustZoneのSecure側で実行
 TOPPERS_SAFEG_NONSECURE : TrustZoneのNonSecure側で実行
 
Secure/NonSecureがそれぞれのプロセッサで何%動作したか(負荷)を計測する
機能を提供する．本機能を使用する場合には，以下のマクロを有効にし，
./syssvc/safeg_load.c をビルド対象とするこ．

 TOPPERS_SAFEG_LOAD
 
使用方法は，まず各コアで初期化関数 safeg_load_init() を呼び出す．次に
safeg_syscall_switch()を呼び出してNonSecure側に移行する直前に
safeg_load_idle()を呼び出す．なお，これらの関数の呼び出しはアトミック
に行う必要があるため，次のようにSILロック状態で呼び出すこと．

    SIL_PRE_LOC;
    SIL_LOC_INT();
    safeg_load_idle();
    ret = safeg_syscall_switch();
    SIL_UNL_INT();
    
OSのアイドル処理によりNonSecure側に移行する場合は特にユーザーで記述す
る必要はない．

負荷は次の関数で取得可能である．

 safeg_load_info(ID prcid, uint32_t *p_trust_load, uint32_t *p_nontrust_load)
    
また，safeg_load_init() を呼び出すと，それまでの履歴は捨て，改めて負荷
の計測を開始する．

○ディフォルトのIDLE処理

ディフォルトのIDLE処理として，wfiによるIDLE処理を用意している．この処
理以外の処理を行う場合は，ターゲット依存部でアセンブラマクロ
(toppers_asm_custom_idle)を定義して，以下のマクロを定義すること．

 TOPPRS_NONUSE_CORE_DEFAULT_CUSTOM_IDLE : ARM64依存部のディフォルトの
                                          IDLE処理を無効に

○GICによるCPUロック

SafeGを用いてSecure側で実行する際は通常はcpsrのFビットで割込みの禁止を
実現するが，NMFI が有効となっていると，Fビットはセットできない．そのた
め，GICの優先度マスクをCPUロックとして使用する機能を提供する．この機能
を有効をするためには，以下のマクロを定義すること．

 USE_GIC_CPULOCK : CPUロックとしてGICの優先度マスクを使用．
 ENABLE_NMFI     : NMFI対応コード

本機能を有効とした場合，次の制約がある．

 ・多重割込みはサポートしていない．
 ・割込みからリターンと割込みの許可がアトミックに出来ないため，タスク
   スタック1段分余分に必要な場合がある．      


=====================================================================
                             変更履歴
=====================================================================
2016/08/18
・core_timer.h : target_timer_probe_int()
  Generic Timerはタイムアウト後はCNTP_CVALを更新するまで，CNTP_TVALの
  値は0のままであるため， target_timer_probe_int()がtrueを返すと
  get_utm()に不整合が発生するため，常にfalseを返すこととする．
  
2016/08/10
・core_timer.h : target_timer_get_current()
  CNTP_TVAL の読み込み値を現在のカウント値として使用するよう変更
  
2015/12/18
・最初のリリース

以上．
