
		TOPPERS/FMPカーネル
		コンフィギュレータ仕様

		対応バージョン: Release 1.4.0
		最終更新: 2015年1月27日

このドキュメントは，TOPPERS/FMPカーネルのコンフィギュレータが標準的に
生成すべきファイルの内容について解説したものである．ターゲット依存に生
成する内容については，このドキュメントの範囲外である．

TOPPERS/FMPカーネルのコンフィギュレータは，TOPPERS/ASPカーネルのコンフ
ィギュレータと共通であるため，本ドキュメントでは，TOPPERS/FMPカーネル
固有の事項についてのみ解説する．そのため，別途TOPPERS/ASPカーネルのコ
ンフィギュレータ仕様も参照すること．

----------------------------------------------------------------------
 TOPPERS/FMP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Flexible MultiProcessor Kernel

 Copyright (C) 2005-2015 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 @(#) $Id: configurator.txt 1194 2016-07-16 00:20:45Z ertl-honda $
----------------------------------------------------------------------

○目次

・生成するファイルの種類
○静的API一覧
◎クラスの指定
○カーネル構成・初期化ヘッダファイル（kernel_cfg.h）
	(1) 固定生成部分
	○(2) オブジェクト数の定義
	(3) オブジェクトのID番号の定義
・カーネル構成・初期化ファイル（kernel_cfg.c）
	(1) 固定生成部分
	(2) カーネルの種類のチェック
	(3) インクルードディレクティブ（#include）の処理
	(4) トレースログマクロのデフォルト定義
	(5) オブジェクトのID番号を保持する変数の定義
	○(6) 各カーネルオブジェクトに関する定義
	○(7) 割込みに関する定義
	○(8) CPU例外に関する定義
	○(9) 非タスクコンテキスト用のスタック領域に関する定義
	○(10) タイムイベント管理に関する定義
	○(11) 各モジュールの初期化関数の定義
	○(12) 初期化ルーチンの実行関数の定義
	○(13) 終了処理ルーチンの実行関数の定義
	◎(14) プロセッサに関する定義

○がついている項目はASPカーネルから変更があった箇所を，◎はFMPカーネル
で新規に追加された箇所を示す．

○生成するファイルの種類

ASPカーネルから変更なし．

○静的API一覧

FMPカーネルのコンフィギュレータが処理する静的APIは次の通り．

(3) 同期・通信機能
	CRE_SPN(ID spnid, { ATR spnatr })


○クラスの指定

FMPカーネルでは，カーネルオブジェクトはいずれか1つのクラスに所属するこ
とから，オブジェクトの登録を行う静的APIは，次のようにクラスの囲みの中
に記述する．

CLASS(<clsid>) {
	そのクラスに属するオブジェクトの登録など
}

clsidは，整数定数式パラメータとする．

○カーネル構成・初期化ヘッダファイル（kernel_cfg.h）

カーネル構成・初期化ヘッダファイル（kernel_cfg.h）には，次の定義を生成
する．

(1) 固定生成部分

ASPカーネルから変更なし．

(2) オブジェクト数の定義

カーネルがサポートするオブジェクトの数をマクロ定義するプリプロセッサディ
レクティブ（#define）を生成する．具体的には，次のような記述を生成する．

#define TNUM_SPNID	<スピンロックの数>

(3) オブジェクトのID番号の定義

ASPカーネルから変更なし．


○カーネル構成・初期化ファイル（kernel_cfg.c）

(1) 固定生成部分

ASPカーネルから変更なし．

(2) カーネルの種類のチェック

ASPカーネルから変更なし．

(3) インクルードディレクティブ（#include）の処理

ASPカーネルから変更なし．

(4) トレースログマクロのデフォルト定義

ASPカーネルから変更なし．

(5) オブジェクトのID番号を保持する変数の定義

ASPカーネルから変更なし．

(6) 各カーネルオブジェクトに関する定義

ASPカーネルから変更なし．

(a) 最大のオブジェクトIDの変数の定義

ASPカーネルから変更なし．

(b) オブジェクトに必要なメモリ領域の定義

オブジェクトによっては，オブジェクトに必要なメモリ領域の定義を生成する．
具体的には，オブジェクト毎の項で説明する．

(c) オブジェクトの初期化ブロックの定義

ASPカーネルから変更なし．

(d) オブジェクトのコントロールブロックの定義

オブジェクトのコントロールブロックの定義を生成する．具体的には，具体的
には，オブジェクトの省略記号を「XXX／xxx」とし，オブジェクトの名前を
「yyy」とすると，オブジェクト毎に次のような行を生成する．

XXXCB _kernel_xxxcb_<オブジェクト名1>;

(e) オブジェクトのコントロールブロックへのアクセステーブル

各オブジェクトのオブジェクトIDを用いてそのオブジェクトのコントロールブ
ロックへアクセスするためのテーブルの定義を生成する．具体的にはオブジェ
クトの省略記号を「XXX／xxx」とすると，次のような行を生成する．

XXXCB* const _kernel_p_xxx_table[TNUM_XXX] = {
	&_kernel_xxxcb_<オブジェクト名1>,
	&_kernel_xxxcb_<オブジェクト名2>,
	...
};

(6-1) タスクに関する定義

ASPカーネルから変更なし．

(6-1-1) タスクに必要なメモリ領域の定義

タスクに必要なメモリ領域として，タスクのスタック領域がある．stkがNULL
の場合には，生成するタスク毎に，指定されたサイズのスタック領域を確保す
る．具体的には，上記の静的APIに対して，次の定義を生成する．

＊stkがNULLの場合のみ生成
static STK_T _kernel_stack_<タスク名>[COUNT_STK_T(stksz)];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_TSKSTKを定義することにより，任意のフォーマットを変更できるた
め，セクション指定等が可能である．

(6-1-2) タスクの初期化情報

タスク初期化ブロック中に生成するタスクの初期化情報は，次の形式とする．

	{ (tskatr), (intptr_t)(exinf), (task), INT_PRIORITY(itskpri),
							(stksz), (stk), (texatr), (texrtn),
							(iaffinity), (affinity_mask) }

iaffinityは初期割付けプロセッサ, affinity_maskは割付け可能プロセッサで
ある．

(6-1-3) タスク生成順序テーブルの定義

ASPカーネルから変更なし．

(6-1-4) エラー条件

タスクに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_TSKがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-2) セマフォに関する定義

ASPカーネルから変更なし．

(6-2-1) セマフォの初期化情報

セマフォ初期化ブロック中に生成するセマフォの初期化情報は，次の形式とす
る．

	{ (sematr), (isemcnt), (maxsem),  (p_obj_lock) }

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-2-2) エラー条件

セマフォに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_SEMがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-3) イベントフラグに関する定義

ASPカーネルから変更なし．

(6-3-1) イベントフラグの初期化情報

	{ (flgatr), (p_obj_lock), (iflgptn) }

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-3-2) エラー条件

イベントフラグに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_FLGがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-4) データキューに関する定義

ASPカーネルから変更なし．

(6-4-1) データキューに必要なメモリ領域の定義

データキューに必要なメモリ領域として，データキュー管理領域がある．生成
するデータキュー毎に，必要なサイズのデータキュー管理領域を定義する．具
体的には，上記の静的APIに対して，次の定義を生成する．

static intptr_t _kernel_dtqmb_<データキュー名>[dtqcnt];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_DTQMBを定義することにより，任意のフォーマットを変更できるため，
セクション指定等が可能である．

(6-4-2) データキューの初期化情報

データキュー初期化ブロック中に生成するデータキューの初期化情報は，次の
形式とする．

	{ (dtqatr), (p_obj_lock), (dtqcnt), (_kernel_dtqmb_<データキュー名>) }

ここで，dtqcntが0の場合には，_kernel_dtqmb_<データキュー名>に代えて，
NULLを用いる．

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-4-3) エラー条件

データキューに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_DTQがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-5) 優先度データキューに関する定義

ASPカーネルから変更なし．

(6-5-1) 優先度データキューに必要なメモリ領域の定義

優先度データキューに必要なメモリ領域として，優先度データキュー管理領域
がある．生成する優先度データキュー毎に，必要なサイズの優先度データキュ
ー管理領域を定義する．具体的には，上記の静的APIに対して，次の定義を生
成する．

static PDQMB _kernel_pdqmb_<優先度データキュー名>[pdqcnt];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_PDTQMBを定義することにより，任意のフォーマットを変更できるた
め，セクション指定等が可能である．

(6-5-2) 優先度データキューの初期化情報

優先度データキュー初期化ブロック中に生成する優先度データキューの初期化
情報は，次の形式とする．

	{ (pdqatr), (p_obj_lock), (pdqcnt), (maxdpri), (_kernel_pdqmb_<優先度データキュー名>) }

ここで，pdqcntが0の場合には，_kernel_pdqmb_<優先度データキュー名>に代え
て，NULLを用いる．

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-5-3) エラー条件

優先度データキューに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_PDQがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-6) メールボックスに関する定義

ASPカーネルから変更なし．

(6-6-1) メールボックスの初期化情報

メールボックス初期化ブロック中に生成するメールボックスの初期化情報は，
次の形式とする．

	{ (mbxatr), (p_obj_lock), (maxmpri) }

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-6-2) エラー条件

メールボックスに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_PDQがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-7) 固定長メモリプールに関する定義

ASPカーネルから変更なし．

(6-7-1) 固定長メモリプールに必要なメモリ領域の定義

固定長メモリプールに必要なメモリ領域として，固定長メモリプール領域と固
定長メモリプール管理領域がある．生成する固定長メモリプール毎に，必要な
サイズの固定長メモリプール領域（mpfがNULLの場合のみ）と固定長メモリプ
ール管理領域を確保する．具体的には，上記の静的APIに対して，次の定義を
生成する．

＊mpfがNULLの場合のみ生成
static MPF_T _kernel_mpf_<固定長メモリプール名>[(blkcnt) * COUNT_MPF_T(blksz)];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_MPF_Tを定義することにより，任意のフォーマットを変更できるため，
セクション指定等が可能である．

＊必ず生成
static MPFMB _kernel_mpfmb_<固定長メモリプール名>[blkcnt];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_MPFMBを定義することにより，任意のフォーマットを変更できるため，
セクション指定等が可能である．

(6-7-2) 固定長メモリプールの初期化情報

固定長メモリプール初期化ブロック中に生成する固定長メモリプールの初期化
情報は，次の形式とする．

	{ (mpfatr), (p_obj_lock), (blkcnt), ROUND_MPF_T(blksz), mpf,
						(_kernel_mpfmb_<固定長メモリプール名>) }

ここで，mpfがNULLの場合には，mpfに代えて，_kernel_mpf_<固定長メモリプー
ル名>を用いる．

p_obj_lockは，オブジェクトロックへのポインタであり，プロセッサロック方
式の場合のみ有効である．

(6-7-3) エラー条件

固定長メモリプールに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_MPFがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-8) 周期ハンドラに関する定義

ASPカーネルから変更なし．

(6-8-1) 周期ハンドラの初期化情報

周期ハンドラ初期化ブロック中に生成する周期ハンドラの初期化情報は，次の
形式とする．

	{ (cycatr), (intptr_t)(exinf), (cychdr), (cyctim), (cycphs),
							 (iaffinity), (affinity_mask) }

iaffinityは初期割付けプロセッサ, affinity_maskは割付け可能プロセッサで
あり，ローカルタイマ方式の場合のみ出力される．

(6-8-2) エラー条件

周期ハンドラに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_CYCがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-9) アラームハンドラに関する定義

ASPカーネルから変更なし．

(6-9-1) アラームハンドラの初期化情報

アラームハンドラ初期化ブロック中に生成するアラームハンドラの初期化情報
は，次の形式とする．

	{ (almatr), (exinf), (almhdr), (iaffinity), (affinity_mask) }

iaffinityは初期割付けプロセッサ, affinity_maskは割付け可能プロセッサで
あり，ローカルタイマ方式の場合のみ出力される．

(6-9-2) エラー条件

アラームハンドラに関するエラー条件は次の通りである．

＊パス2で検出するもの
・CRE_ALMがクラスの囲みの中に記述されていない場合（E_RSATR）

(6-10) スピンロックに関する定義

スピンロックの省略記号は「SPN／spn」である．以下では，システムコンフィ
ギュレーションファイルに次の静的APIが含まれている時に生成すべき情報に
ついて述べる．なお，スピンロックに必要なメモリ領域はない．

CRE_SPN(ID spnid, {spnatr});

(6-10-1) スピンロックの初期化情報

スピンロック初期化ブロック中に生成するスピンロックの初期化情報は，次の
形式とする．

	{ (spnatr), (p_obj_lock) }

p_obj_lockは，オブジェクトロックへのポインタであり，スピンロックの方式
がエミュレーション方式かつプロセッサロック方式の場合のみ有効である．

(6-10-2) エラー条件

スピンロックに関するエラー条件は次の通りである．

＊コンフィギュレータ本体が検出するもの
・同じspnidに対するCRE_SPNが複数ある場合（E_OBJ）

＊パス2で検出するもの
・CRE_SPNがクラスの囲みの中に記述されていない場合（E_RSATR）
・割付け可能なハードウェアスピンロックハードウェアがない（E_NOID）
  (ネイティブスピンロック方式の場合)

・sematrが（［TA_TPRI］）でない場合（E_RSATR）
・(0 <= isemcnt && isemcnt <= maxsem)でない場合（E_PAR）
・(1 <= maxsem && maxsem <= TMAX_MAXSEM)でない場合（E_PAR）

(7) 割込みに関する定義

ASPカーネルから変更なし．

(7-1) 割込み要求ラインに関する定義

ASPカーネルから変更なし．

(7-1-1) 設定する割込み要求ラインの数

ASPカーネルから変更なし．

(7-1-2) 割込み要求ライン初期化ブロックの定義

この中の割込み要求ラインの初期化情報は，次の形式とする．

	{ (intno), (intatr), (intpri), (iaffinity), (affinity_mask) }

iaffinityは初期割付けプロセッサ, affinity_maskは割付け可能プロセッサで
ある．

(7-1-3) エラー条件

割込み要求ラインに関するエラー条件は次の通りである．

＊パス2で検出するもの
・intnoがCFG_INTに対する割込み番号として正しくない場合（E_PAR）
  ・intnoの上位ビットで指定した割込み可能プロセッサとクラスで指定され
    ている割付け可能プロセッサが矛盾する場合．
・CFG_INTがクラスの囲みの中に記述されていない場合（E_RSATR）
・対応するDEF_INH/ATT_ISRと異なるクラスに属する場合（E_RSATR）

(7-2) 割込みサービスルーチンに関する定義

(7-2-1) 割込みハンドラの生成

ASPカーネルから変更なし．

(7-2-2) 割込みハンドラの定義に相当する処理

ASPカーネルから変更なし．

(7-2-3) エラー条件

割込みサービスルーチンに関するエラー条件は次の通りである．

＊パス2で検出するもの
・intnoがATT_ISRに対する割込み番号として正しくない場合（E_PAR）
  ・intnoの上位ビットで指定した割込み可能プロセッサとクラスで指定され
    ている割付け可能プロセッサが矛盾する場合．
・ATT_ISRがクラスの囲みの中に記述されていない場合（E_RSATR）
・対応するCFG_INTと異なるクラスに属する場合（E_RSATR）

(7-3) 割込みハンドラに関する定義

ASPカーネルから変更なし．

(7-3-1) 定義する割込みハンドラの数

ASPカーネルから変更なし．

(7-3-2) 割込みハンドラの出入口処理

ASPカーネルから変更なし．

(7-3-3) 割込みハンドラ初期化ブロックの定義

この中の割込みハンドラの初期化情報は，次の形式とする．

	{ (inhno), (inhatr), (FP)(INT_ENTRY(inhno, inthdr)), (iaffinity), (affinity_mask) }

iaffinityは初期割付けプロセッサ, affinity_maskは割付け可能プロセッサで
ある．

(7-3-4) エラー条件

割込みハンドラに関するエラー条件は次の通りである．

＊パス2で検出するもの
・intnoがDEF_INHに対する割込み番号として正しくない場合（E_PAR）
  ・intnoの上位ビットで指定した割込み可能プロセッサとクラスで指定され
    ている割付け可能プロセッサが矛盾する場合．
・ATT_ISRがクラスの囲みの中に記述されていない場合（E_RSATR）
・対応するCFG_INTと異なるクラスに属する場合（E_RSATR）

(8) CPU例外に関する定義

ASPカーネルから変更なし．

(8-1) 定義するCPU例外ハンドラの数

ASPカーネルから変更なし．

(8-2) CPU例外ハンドラの出入口処理

ASPカーネルから変更なし．

(8-3) CPU例外ハンドラ初期化ブロックの定義

ASPカーネルから変更なし．

(8-4) エラー条件

CPU例外ハンドラに関するエラー条件は次の通りである．

＊パス2で検出するもの
・DEF_EXCがクラスの囲みの中に記述されていない場合（E_RSATR）

(9) 非タスクコンテキスト用のスタック領域に関する定義

ASPカーネルから変更なし．

(9-1) DEF_ICSがない場合

システムコンフィギュレーションファイルに，静的API「DEF_ICS」が含まれて
いない場合には，プロセッサIDを「x」とするとプロセッサ毎に次のような行
を生成する．

#ifdef DEFAULT_PRCx_ISTK
#define TOPPERS_PRCx_ISTKSZ		DEFAULT_PRCx_ISTKSZ
#define TOPPERS_PRCx_ISTK		DEFAULT_PRCx_ISTK
#else /* DEFAULT_ISTK */
static STK_T				_kernel_prcx_istack[COUNT_STK_T(DEFAULT_PRCx_ISTKSZ)];
#define TOPPERS_PRCx_ISTKSZ	ROUND_STK_T(DEFAULT_PRCx_ISTKSZ)
#define TOPPERS_PRCx_ISTK	_kernel_prcx_istack
#endif /* DEFAULT_ISTK */

_kernel_prcx_istack に関しては，ターゲット依存部のコンフィギュレータテ
ンプレートファイルで，関数GENERATE_ISTACKを定義することにより，任意の
フォーマットを変更できるため，セクション指定等が可能である．

(9-2) DEF_ICSがある場合

istkがNULLの場合には，指定されたサイズの非タスクコンテキスト用のスタッ
ク領域を確保し，非タスクコンテキスト用のスタック領域の初期化情報を生成
する．具体的には，上記の静的APIに対して，プロセッサIDを「x」とすると，
次の行を生成する．

static STK_T				_kernel_prcx_istack[COUNT_STK_T(istksz)];
#define TOPPERS_PRCx_ISTKSZ	ROUND_STK_T(istksz)
#define TOPPERS_PRCx_ISTK	_kernel_istack

_kernel_prcx_istack に関しては，ターゲット依存部のコンフィギュレータテ
ンプレートファイルで，関数GENERATE_ISTACK_ICSを定義することにより，任
意のフォーマットを変更できるため，セクション指定等が可能である．

istkがNULLでない場合には，非タスクコンテキスト用のスタック領域の初期化
情報を，プロセッサIDを「x」とすると，次の形式で生成する．

#define TOPPERS_PRCx_ISTKSZ		(istksz)
#define TOPPERS_PRCx_ISTK		(istk)

(9-3) 変数の生成

DEF_ICSの有無によらず，次の定義を生成する．「x/y」は，プロセッサIDを示
す．

const SIZE		_kernel_istksz_table[TNUM_PRCID] = {
	TOPPERS_PRCx_ISTKSZ,
	TOPPERS_PRCy_ISTKSZ,
	...
};

STK_T *const	_kernel_istk_table[TNUM_PRCID] = {
	TOPPERS_PRCx_ISTK,
	TOPPERS_PRCy_ISTK,
	...
}

#ifdef TOPPERS_ISTKPT
STK_T *const	_kernel_istkpt_table[TNUM_PRCID] = {
	TOPPERS_ISTKPT(TOPPERS_PRCx_ISTK, TOPPERS_PRCx_ISTKSZ),
	TOPPERS_ISTKPT(TOPPERS_PRCy_ISTK, TOPPERS_PRCy_ISTKSZ),
	...
}
#endif /* TOPPERS_ISTKPT */

(9-4) エラー条件

非タスクコンテキスト用のスタック領域に関するエラー条件は次の通りである．

＊パス2で検出するもの
・1つのプロセッサに対する静的API「DEF_ICS」が複数ある（E_OBJ）

(10) タイムイベント管理に関する定義

タイムイベント管理に関連して，次の定義を生成する．

(a)クローバルタイマ方式

TMEVTN	_kernel_tmevt_heap[TNUM_TSKID + TNUM_CYCID + TNUM_ALMID];

(b)ローカルタイマ方式

プロセッサ毎に，以下の定義を生成する．「x」はプロセッサIDを示す．

TMEVTN	_kernel_prcx_tmevt_heap[TNUM_TSKID + TNUM_CYCID + TNUM_ALMID];

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_TMEVTN_HEAPを定義することにより，任意のフォーマットを変更でき
るため，セクション指定等が可能である．

また，上記配列へのアクセスのためのテーブルを生成する．「x/y」はプロセ
ッサIDを示す．

TEVTCB* const _kernel_p_tevtcb_table[TNUM_PRCID] = {
	 &_kernel_prcx_tevtcb,
	 &_kernel_prcy_tevtcb,
	...
};

(11) 各モジュールの初期化関数の定義

ASPカーネルから変更なし．

(12) 初期化ルーチンの実行関数の定義

初期化ルーチンは，クラスに属さないグローバル初期化ルーチンとクラスに属
するローカル初期化ルーチンに分けられる．

ATT_INI({ TA_NULL, 0, timer_initialize });

CLASS(1){
	ATT_INI({ TA_NULL, CONSOLE_PORTID1, serial_initialize });
}

CLASS(2){
	ATT_INI({ TA_NULL, CONSOLE_PORTID2, serial_initialize });
}

という3つの静的APIがこの順序で記述された時に生成する関数は次の通りであ
る．クラスID1,2の初期割付けプロセッサのIDはそれぞれ1,2である．

void
_kernel_call_global_inirtn(void)
{
	(timer_initialize)((intptr_t)(0));
}

void
_kernel_call_inirtn(void)
{
	if (x_prc_index() == INDEX_PRC(1)) {
		(serial_initialize)((intptr_t)(CONSOLE_PORTID1));
	}
	if (x_prc_index() == INDEX_PRC(2)) {
		(serial_initialize)((intptr_t)(CONSOLE_PORTID2));
	}
}

(13-1) エラー条件

ASPカーネルから変更なし．

(13) 終了処理ルーチンの実行関数の定義

終了処理ルーチンは，クラスに属さないグローバル終了処理ルーチンと，クラ
スに属するローカル初期化ルーチンに分かれる．

ATT_TER({ TA_NULL, 0, timer_terminate });

CLASS(1){
	ATT_TER({ TA_NULL, CONSOLE_PORTID1, serial_terminate });
}

CLASS(2){
	ATT_TER({ TA_NULL, CONSOLE_PORTID1, serial_terminate });
}

という3つの静的APIがこの順序で記述された時に生成する関数は次の通りであ
る．

void
_kernel_call_global_terrtn(void)
{
	(timer_terminate)((intptr_t)(0));
}

void
_kernel_call_local_terrtn(void)
{
	if (x_prc_index() == INDEX_PRC(1)) {
		(serial_terminate)((intptr_t)(CONSOLE_PORTID1));
	}

	if (x_prc_index() == INDEX_PRC(2)) {
		(serial_terminate)((intptr_t)(CONSOLE_PORTID2));
	}
}

(13-1) エラー条件

ASPカーネルから変更なし．

(14) プロセッサに関する定義

(a) コントロールブロックの定義

プロセッサ毎にプロセッサコントロールブロック(Processor Control Block)
の定義を生成する．具体的には，プロセッサIDを「x」とするとプロセッサ毎
に次のような行を生成する．

PCB _kernel_prcX_pcb;

ターゲット依存部のコンフィギュレータテンプレートファイルで，関数
GENERATE_PCBを定義することにより，任意のフォーマットを変更できるため，
セクション指定等が可能である．

(b) プロセッサコントロールブロックへのアクセステーブル

各プロセッサのプロセッサIDを用いてそのプロセッサのプロセッサコントロー
ルブロックへアクセスするためのテーブルの定義を生成する．具体的には次の
ような行を生成する．

PCB* const _kernel_p_pcb_table[TNUM_PRCID] = {
	&_kernel_prc1_pcb,
	&_kernel_prc2_pcb,
	...
};


以上
